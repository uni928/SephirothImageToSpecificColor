<html lang="ja">
<head>
    <title>画像をセーフカラーのみの構成にするサイト | Gifted Style</title>
    <meta name="description" content="画像をセーフカラーのみの構成にするサイトです。"/>
    <style>
.progress {
  border-radius: 30px;
  height: 40px;
  background: #ddd;
  overflow: hidden;
}
.bar {
  background: #FFC100;
  border-radius: inherit;
  height: 100%;
  width: 0%;
  transition: 2s;
}
    </style>
</head>
<body>
<img src="" id="preview">
<canvas id="canvas"></canvas>
<canvas id="canvas2"></canvas></br>
<input type="file" accept="image/*" id="getfile"></br>
<div class="progress">
  <div class="bar" id="Bar"></div>
</div></br></br>
このサイトは画像をセーフカラーのみにした場合に</br>
どんな見た目になるかどうかを軽くチェックするサイトです。</br></br>
画像ファイルを選択すると</br>
左右にその画像が展開されます。</br>
そして右側の画像がセーフカラーに変換されていきます。</br></br>
境界線が乱れるため</br>
このサイトで変換した物を</br>
完成品にするのは難しいですが</br>
画像を修正する際の指標にする事ができます。</br></br>
<a href="https://www.colordic.org/s" target="_blank">このサイト</a> に載っているいずれかの色に変換します。</br></br>
3 番目に出現する画像は</br>
2 番目の画像のノイズ削除処理をしたものです。</br>
5 × 5 のメディアンフィルタです。</br></br>
<script>
function MyThread(i, ctx, canvas) {
for(let j = 0; j < canvas.height; j++) {
          const imageData = ctx.getImageData(i, j, 1, 1);
          let r = imageData.data[0];
          let g = imageData.data[1];
          let b = imageData.data[2];
          let a = imageData.data[3];
          let array = ["#000000" ,"#ffffcc" ,"#99ff99" ,"#66ffff" ,"#3333ff" ,"#ff00ff" ,"#333333" ,"#ffff99" ,"#66ff66" ,"#33ffff" ,"#0000ff" ,"#ff00cc" ,"#666666" ,"#ffff66" ,"#33ff33" ,"#00ffff" ,"#3300ff" ,"#cc0099" ,"#999999" ,"#ffff33" ,"#00ff00" ,"#00ccff" ,"#3300cc" ,"#ff33cc" ,"#cccccc" ,"#ffff00" ,"#00ff33" ,"#0099cc" ,"#6633ff" ,"#990066" ,"#ffffff" ,"#ccff00" ,"#00cc33" ,"#33ccff" ,"#330099" ,"#cc3399" ,"#ff3300" ,"#99cc00" ,"#33ff66" ,"#006699" ,"#6633cc" ,"#ff66cc" ,"#cc3300" ,"#ccff33" ,"#009933" ,"#3399cc" ,"#9966ff" ,"#ff0099" ,"#ff6633" ,"#669900" ,"#33cc66" ,"#66ccff" ,"#6600ff" ,"#660033" ,"#993300" ,"#99cc33" ,"#66ff99" ,"#0099ff" ,"#330066" ,"#993366" ,"#cc6633" ,"#ccff66" ,"#00ff66" ,"#003366" ,"#663399" ,"#cc6699" ,"#ff9966" ,"#99ff00" ,"#006633" ,"#336699" ,"#9966cc" ,"#cc0066" ,"#ff6600" ,"#336600" ,"#339966" ,"#6699cc" ,"#6600cc" ,"#ff99cc" ,"#663300" ,"#669933" ,"#66cc99" ,"#0066cc" ,"#cc99ff" ,"#ff3399" ,"#996633" ,"#99cc66" ,"#00cc66" ,"#99ccff" ,"#9933ff" ,"#ff0066" ,"#cc9966" ,"#66cc00" ,"#99ffcc" ,"#3399ff" ,"#9900ff" ,"#990033" ,"#cc6600" ,"#ccff99" ,"#33ff99" ,"#0066ff" ,"#660099" ,"#cc3366" ,"#ffcc99" ,"#99ff33" ,"#00ff99" ,"#003399" ,"#9933cc" ,"#ff6699" ,"#ff9933" ,"#66ff00" ,"#009966" ,"#3366cc" ,"#cc66ff" ,"#cc0033" ,"#ff9900" ,"#339900" ,"#33cc99" ,"#6699ff" ,"#9900cc" ,"#ff3366" ,"#996600" ,"#66cc33" ,"#66ffcc" ,"#0033cc" ,"#cc33ff" ,"#ff0033" ,"#cc9933" ,"#99ff66" ,"#00cc99" ,"#3366ff" ,"#cc00ff" ,"#330000" ,"#ffcc66" ,"#33cc00" ,"#33ffcc" ,"#0033ff" ,"#330033" ,"#663333" ,"#cc9900" ,"#66ff33" ,"#00ffcc" ,"#000033" ,"#663366" ,"#660000" ,"#ffcc33" ,"#33ff00" ,"#003333" ,"#333366" ,"#660066" ,"#996666" ,"#ffcc00" ,"#003300" ,"#336666" ,"#000066" ,"#996699" ,"#993333" ,"#333300" ,"#336633" ,"#006666" ,"#666699" ,"#993399" ,"#990000" ,"#666633" ,"#006600" ,"#669999" ,"#333399" ,"#990099" ,"#cc9999" ,"#666600" ,"#669966" ,"#339999" ,"#000099" ,"#cc99cc" ,"#cc6666" ,"#999966" ,"#339933" ,"#009999" ,"#9999cc" ,"#cc66cc" ,"#cc3333" ,"#999933" ,"#009900" ,"#99cccc" ,"#6666cc" ,"#cc33cc" ,"#cc0000" ,"#999900" ,"#99cc99" ,"#66cccc" ,"#3333cc" ,"#cc00cc" ,"#ffcccc" ,"#cccc99" ,"#66cc66" ,"#33cccc" ,"#0000cc" ,"#ffccff" ,"#ff9999" ,"#cccc66" ,"#33cc33" ,"#00cccc" ,"#ccccff" ,"#ff99ff" ,"#ff6666" ,"#cccc33" ,"#00cc00" ,"#ccffff" ,"#9999ff" ,"#ff66ff" ,"#ff3333" ,"#cccc00" ,"#ccffcc" ,"#99ffff" ,"#6666ff" ,"#ff33ff" ,"#ff0000"];

    let result = "";
    let resultR = 0;
    let resultG = 0;
    let resultB = 0;
    let point = 1000000;
    
    array.forEach(function(one){
      let r2 = parseInt(one.substring(1, 3), 16);
      let g2 = parseInt(one.substring(3, 5), 16);
      let b2 = parseInt(one.substring(5, 7), 16);
      let targetPoint = Math.abs(r - r2) + Math.abs(g - g2) + Math.abs(b - b2);
      if(targetPoint < point) {
        point = targetPoint;
        result = one;
        resultR = r2;
        resultG = g2;
        resultB = b2;
      }
    });
    ctx.fillStyle = "rgba(" + resultR + "," + resultG + "," + resultB + "," + a / 255 + ")";
    ctx.fillRect(i, j, 1, 1);
}

        const diff = canvas.width - i;
    	const widthPercentage = (i / canvas.width) * 100 / 2;
    	document.getElementById('Bar').style.width = widthPercentage + '%';
    if(i == canvas.width - 1) {
      MyThread2(ctx, canvas);
    }
}

async function MyThread2(ctx2, canvas2) {
  const canvas = document.getElementById('canvas2');
  const ctx = canvas.getContext('2d', { willReadFrequently: true });
  canvas.width = canvas2.width;
  canvas.height = canvas2.height;
  for(let i = 0; i < canvas2.width; i++) {
    for(let j = 0; j < canvas2.height; j++) {
      const imageData = ctx2.getImageData(i, j, 1, 1);
      ctx.fillStyle = "rgba(" + imageData.data[0] + "," + imageData.data[1] + "," + imageData.data[2] + "," + imageData.data[3] / 255 + ")";
      ctx.fillRect(i, j, 1, 1);
    }
  }
  let resultArrayR = [];
  let resultArrayG = [];
  let resultArrayB = [];
  let resultArrayA = [];
  for(let i = 0; i < canvas.width; i++) {
  for(let j = 0; j < canvas.height; j++) {
  let arrayR = [];
  let arrayG = [];
  let arrayB = [];
  resultArrayA.push(ctx.getImageData(i, j, 1, 1).data[3]);
  for(let i2 = i - 2; i2 <= i + 2; i2++) {
  for(let j2 = j - 2; j2 <= j + 2; j2++) {
    if(i2 < 0 || canvas.width <= i2 || j2 < 0 || canvas.height <= j2) continue;
    const imageData = ctx.getImageData(i2, j2, 1, 1);
    arrayR.push(imageData.data[0]);
    arrayG.push(imageData.data[1]);
    arrayB.push(imageData.data[2]);
  }
  }
  for(let i2 = 0; i2 < arrayR.length; i2++) {
  for(let j2 = i2 + 1; j2 < arrayR.length; j2++) {
    if(arrayR[i2] + arrayG[i2] + arrayB[i2] < arrayR[j2] + arrayG[j2] + arrayB[j2]) {
      let oneTimeR = arrayR[i2];
      let oneTimeG = arrayG[i2];
      let oneTimeB = arrayB[i2];
      arrayR[i2] = arrayR[j2];
      arrayG[i2] = arrayG[j2];
      arrayB[i2] = arrayB[j2];
      arrayR[j2] = oneTimeR;
      arrayG[j2] = oneTimeG;
      arrayB[j2] = oneTimeB;
    }
  }
  }
  //console.log(arrayR.length);
  if(arrayR.length == 25) {
    resultArrayR.push(arrayR[12]);
    resultArrayG.push(arrayG[12]);
    resultArrayB.push(arrayB[12]);
  }
  else {
    resultArrayR.push(arrayR[8]);
    resultArrayG.push(arrayG[8]);
    resultArrayB.push(arrayB[8]);
  }
  if(2 < i) {
  ctx.fillStyle = "rgba(" + resultArrayR[(i - 3) * canvas.height + j] + "," + resultArrayG[(i - 3) * canvas.height + j] + "," + resultArrayB[(i - 3) * canvas.height + j] + "," + resultArrayA[(i - 3) * canvas.height + j] / 255 + ")";
  ctx.fillRect(i - 3, j, 1, 1);

  if(i == canvas.width - 1) {
  ctx.fillStyle = "rgba(" + resultArrayR[(i - 2) * canvas.height + j] + "," + resultArrayG[(i - 2) * canvas.height + j] + "," + resultArrayB[(i - 2) * canvas.height + j] + "," + resultArrayA[(i - 2) * canvas.height + j] / 255 + ")";
  ctx.fillRect(i - 2, j, 1, 1);

    ctx.fillStyle = "rgba(" + resultArrayR[(i - 1) * canvas.height + j] + "," + resultArrayG[(i - 1) * canvas.height + j] + "," + resultArrayG[(i - 1) * canvas.height + j] + "," + resultArrayA[(i - 1) * canvas.height + j] / 255 + ")";
  ctx.fillRect(i - 1, j, 1, 1);

    ctx.fillStyle = "rgba(" + resultArrayR[i * canvas.height + j] + "," + resultArrayG[i * canvas.height + j] + "," + resultArrayB[i * canvas.height + j] + "," + resultArrayA[i * canvas.height + j] / 255 + ")";
  ctx.fillRect(i, j, 1, 1);
  }
  }
  }

  const widthPercentage = (i / canvas.width + 1) * 100 / 2;
  document.getElementById('Bar').style.width = widthPercentage + '%';
  const sleep = ms => new Promise(resolve => setTimeout(resolve, ms))
  await sleep(0);
  }
}

var file = document.querySelector('#getfile');

file.onchange = function (){
  var fileList = file.files;
  //読み込み
  var reader = new FileReader();
  reader.readAsDataURL(fileList[0]); 

  //読み込み後
  reader.onload = function  () {
    document.querySelector('#preview').src = reader.result;

    const canvas2 = document.getElementById('canvas2');
    canvas2.width = 0;
    canvas2.height = 0;

    const image = document.getElementById('preview');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d', { willReadFrequently: true });
image.onload = function() {
    canvas.width = image.width;
    canvas.height = image.height;
    ctx.drawImage(image, 0, 0);
    setTimeout(() => {
  for(let i = 0; i < canvas.width; i++) {
    setTimeout(() => {
      MyThread(i, ctx, canvas);
    }, 0);
  };
}, 0);
};
};
};


</script> 
</body>
</html>
